# Benthos configuration for AIOps NAAS v0.4 Enhanced Cross-Source Correlation
# This configuration implements comprehensive rule-based correlation across logs, metrics, SNMP data, and applications
# FIXED VERSION - Addresses null handling and cache key issues

http:
  enabled: true
  address: "0.0.0.0:4195"
  debug_endpoints: true

# Input: Consume events from multiple sources for comprehensive correlation
input:
  broker:
    inputs:
      # Anomaly events from basic anomaly detection
      - nats:
          urls: ["nats://nats:4222"]
          subject: "anomaly.detected"
          
      # Enriched anomaly events from enhanced anomaly detection
      - nats:
          urls: ["nats://nats:4222"]
          subject: "anomaly.detected.enriched"
          
      # Application log anomalies from application-log-collector
      - nats:
          urls: ["nats://nats:4222"]
          subject: "logs.anomalous"
          
      # SNMP network anomalies
      - nats:
          urls: ["nats://nats:4222"]
          subject: "telemetry.network.anomaly"

# Pipeline for comprehensive event processing and cross-source correlation
pipeline:
  processors:
    # CRITICAL FIX: Filter out INFO/DEBUG level events early to prevent incident creation
    - switch:
      - check: |
          let severity = if this.severity != null { this.severity.lowercase() } else if this.level != null { this.level.lowercase() } else if this.metadata != null && this.metadata.anomaly_severity != null { this.metadata.anomaly_severity.lowercase() } else { "info" }
          let anomaly_score = if this.anomaly_score != null { this.anomaly_score } else { 0.0 }
          
          # Skip INFO/DEBUG logs unless they have high anomaly scores
          (severity == "info" || severity == "debug" || severity == "trace") && anomaly_score < 0.7
        processors:
          - mapping: "root = deleted()"  # Drop the event
      
      # Process all other events (ERROR, CRITICAL, WARNING, or high-score INFO)  
      - processors:
          - mapping: |
              # Log what we're processing for debugging
              root.benthos_processing = {
                "filtered_in": true,
                "severity": if this.severity != null { this.severity } else if this.level != null { this.level } else { "unknown" },
                "anomaly_score": if this.anomaly_score != null { this.anomaly_score } else { 0.0 },
                "processing_timestamp": now()
              }
    
    # Input validation and standardization with comprehensive null handling
    - mapping: |
        # Log raw input for debugging purposes
        root.debug_input = {
          "raw_content": content(),
          "content_type": content().type(),
          "timestamp": now(),
          "metadata": meta()
        }
        
        # Validate and standardize input format with null safety
        if content().type() == "string" {
          # Try to parse as JSON first, fallback to plain text on failure
          let is_json = content().length() > 0 && (content().slice(0, 1) == "{" || content().slice(0, 1) == "[")
          root = if is_json {
            # Attempt JSON parsing with error handling
            if content().parse_json() != null {
              content().parse_json()
            } else {
              # JSON parsing failed, treat as plain text
              {
                "message": content(),
                "level": "INFO",
                "timestamp": now(),
                "source": "raw_text",
                "host": "unknown"
              }
            }
          } else {
            # Not JSON format, treat as plain text log
            {
              "message": content(),
              "level": "INFO",
              "timestamp": now(),
              "source": "raw_text",
              "host": "unknown"
            }
          }
        } else if content().type() == "object" {
          # Already an object, use as-is but ensure required fields
          root = this
        } else {
          # Unknown format, wrap in standardized structure
          root = {
            "message": content().string(),
            "level": "INFO", 
            "timestamp": now(),
            "source": "unknown_format",
            "host": "unknown"
          }
        }

    # Core field normalization with defensive null handling
    - mapping: |
        # Generate correlation ID if missing
        root.correlation_id = if this.correlation_id != null && this.correlation_id != "" { 
          this.correlation_id 
        } else { 
          uuid_v4() 
        }
        root.processing_timestamp = now()
        
        # Normalize ship_id with multiple fallback strategies and track derivation source
        let ship_derivation_result = if this.ship_id != null && this.ship_id != "" && !this.ship_id.contains("unknown") { 
          {"ship_id": this.ship_id, "source": "original_field"}
        } else if this.host != null && this.host != "" && !this.host.contains("unknown") { 
          # Try to derive ship_id from hostname
          if this.host.contains("-") {
            {"ship_id": this.host.split("-").index(0) + "-ship", "source": "hostname_derived"}
          } else {
            {"ship_id": this.host, "source": "hostname_direct"}
          }
        } else if this.metadata != null && this.metadata.source_host != null && this.metadata.source_host != "" && !this.metadata.source_host.contains("unknown") { 
          # Try to derive from metadata.source_host (common in anomaly events)
          if this.metadata.source_host.contains("-") {
            {"ship_id": this.metadata.source_host.split("-").index(0) + "-ship", "source": "metadata_source_host_derived"}
          } else {
            {"ship_id": this.metadata.source_host, "source": "metadata_source_host_direct"}
          }
        } else if this.labels != null && this.labels.instance != null && this.labels.instance != "" { 
          # Try to derive from instance label
          if this.labels.instance.contains("-") {
            {"ship_id": this.labels.instance.split("-").index(0) + "-ship", "source": "instance_label_derived"}
          } else {
            {"ship_id": this.labels.instance, "source": "instance_label_direct"}
          }
        } else { 
          {"ship_id": "unknown-ship", "source": "fallback"}
        }
        
        root.ship_id = ship_derivation_result.ship_id
        root.ship_id_source = ship_derivation_result.source
        
        # Normalize host field for device registry lookup
        root.host = if this.host != null && this.host != "" {
          this.host
        } else if this.metadata != null && this.metadata.source_host != null && this.metadata.source_host != "" {
          this.metadata.source_host
        } else if this.labels != null && this.labels.instance != null && this.labels.instance != "" {
          this.labels.instance
        } else {
          "unknown"
        }
        
        # Derive human-readable ship_name from ship_id
        root.ship_name = if root.ship_id != null && root.ship_id != "" {
          if root.ship_id == "unknown-ship" {
            "Unknown Ship"
          } else if root.ship_id.contains("-ship") && root.ship_id.length() > 5 {
            # Remove "-ship" suffix and convert to proper case for display
            if root.ship_id.slice(0, root.ship_id.length() - 5).contains("-") {
              # Convert "msc-aurora" to "MSC AURORA"
              root.ship_id.slice(0, root.ship_id.length() - 5).split("-").map_each(word -> word.uppercase()).join(" ")
            } else {
              # Convert "aurora" to "AURORA" for single words  
              root.ship_id.slice(0, root.ship_id.length() - 5).uppercase()
            }
          } else {
            # For non-standard ship_id formats, capitalize first letter
            root.ship_id.capitalize()
          }
        } else {
          "Unknown Ship"
        }
        
        # Add ship registry metadata for debugging and monitoring
        root.registry_metadata = {
          "ship_id_source": root.ship_id_source,
          "original_host": if this.host != null { this.host } else { "not_available" },
          "resolved_ship_id": root.ship_id,
          "resolved_ship_name": root.ship_name,
          "derivation_timestamp": now()
        }
        
        # Normalize event source with fallbacks
        root.event_source = if this.event_source != null && this.event_source != "" { 
          this.event_source 
        } else if this.source != null && this.source != "" { 
          this.source 
        } else if this.anomaly_type != null && this.anomaly_type == "log_pattern" {
          "application_logs"
        } else if this.detector_name != null && this.detector_name.contains("network") {
          "snmp_network"
        } else if this.correlation_level != null && this.correlation_level == "level_1_enriched" {
          "enriched_metrics"
        } else { 
          "basic_metrics" 
        }
        
        # Normalize metric name with contextual fallbacks
        root.metric_name = if this.metric_name != null && this.metric_name != "" { 
          this.metric_name 
        } else if this.message != null && this.message.contains("CPU") { 
          "cpu_usage" 
        } else if this.message != null && (this.message.contains("memory") || this.message.contains("Memory")) { 
          "memory_usage" 
        } else if root.event_source == "application_logs" {
          "log_anomaly"
        } else if root.event_source == "snmp_network" {
          "interface_utilization"
        } else { 
          "unknown_metric" 
        }
        
        # Normalize severity with comprehensive mapping
        root.severity = if this.severity != null && this.severity != "" { 
          this.severity 
        } else if this.level != null {
          if this.level.lowercase() == "error" || this.level.lowercase() == "fatal" {
            "critical"
          } else if this.level.lowercase() == "warn" || this.level.lowercase() == "warning" {
            "warning"  
          } else if this.level.lowercase() == "info" || this.level.lowercase() == "information" {
            "info"
          } else if this.level.lowercase() == "debug" || this.level.lowercase() == "trace" {
            "debug"
          } else {
            "info"
          }
        } else {
          "info"
        }
        
        # Normalize anomaly score
        root.anomaly_score = if this.anomaly_score != null { 
          this.anomaly_score 
        } else if root.severity == "critical" {
          0.9
        } else if root.severity == "warning" {
          0.6
        } else {
          0.4
        }
        
        # Normalize service information with enhanced metadata extraction
        root.service = if this.service != null && this.service != "" {
          this.service
        } else if this.metadata != null && this.metadata.service != null && this.metadata.service != "" {
          this.metadata.service
        } else if this.labels != null && this.labels.job != null && this.labels.job != "" {
          this.labels.job
        } else if this.application != null && this.application != "" {
          this.application
        } else {
          "unknown_service"
        }
        
        # CRITICAL FIX: Extract and preserve metric values from metadata
        root.metric_value = if this.metric_value != null {
          this.metric_value
        } else if this.value != null {
          this.value  
        } else if this.metadata != null && this.metadata.metric_value != null {
          this.metadata.metric_value
        } else {
          0.0
        }
        
        # CRITICAL FIX: Extract device_id from multiple sources
        root.device_id = if this.device_id != null && this.device_id != "" {
          this.device_id
        } else if this.metadata != null && this.metadata.device_id != null && this.metadata.device_id != "" {
          this.metadata.device_id
        } else if this.host != null && this.host != "" && this.host != "unknown" {
          this.host
        } else if this.labels != null && this.labels.instance != null && this.labels.instance != "" {
          this.labels.instance
        } else {
          "unknown-device"
        }
        
        # CRITICAL FIX: Extract tracking_id for traceability
        root.tracking_id = if this.tracking_id != null && this.tracking_id != "" {
          this.tracking_id
        } else if this.metadata != null && this.metadata.tracking_id != null && this.metadata.tracking_id != "" {
          this.metadata.tracking_id
        } else if this.correlation_id != null && this.correlation_id != "" {
          this.correlation_id
        } else {
          null
        }
        
        # Safe incident type handling
        root.incident_type = if this.incident_type != null && this.incident_type != "" {
          this.incident_type
        } else {
          "single_anomaly"
        }
        
        # Add processing metadata
        root.input_metadata = {
          "original_format": content().type(),
          "standardized": true,
          "validation_timestamp": now(),
          "processing_stage": "normalization"
        }

    # Enhanced context enrichment
    - mapping: |
        # Identify if this is enriched data
        root.is_enriched = this.correlation_level != null && this.correlation_level == "level_1_enriched"
        
        # Preserve enrichment context safely
        root.enrichment_context = if this.enrichment_context != null { this.enrichment_context } else { {} }
        root.maritime_context = if this.maritime_context != null { this.maritime_context } else { {} }
        root.operational_status = if this.operational_status != null { this.operational_status } else { "normal" }
        
        # Add source-specific context
        if root.event_source == "application_logs" {
          root.app_context = {
            "logger_name": if this.logger_name != null { this.logger_name } else { "" },
            "trace_id": if this.trace_id != null { this.trace_id } else { "" },
            "span_id": if this.span_id != null { this.span_id } else { "" },
            "thread": if this.thread != null { this.thread } else { "" },
            "application": if this.application != null { this.application } else { "" }
          }
        } else {
          root.app_context = {}
        }
        
        if root.event_source == "snmp_network" {
          root.network_context = {
            "device_type": if this.labels != null && this.labels.device_type != null { this.labels.device_type } else { "" },
            "device_ip": if this.host != null { this.host } else { "" },
            "interface": if this.labels != null && this.labels.interface != null { this.labels.interface } else { "" },
            "metric_name": root.metric_name
          }
        } else {
          root.network_context = {}
        }

    # Store events in correlation cache with safe key generation
    - cache:
        resource: "correlation_cache"  
        operator: "set"
        key: "${! json(\"ship_id\") + \"_\" + json(\"event_source\") + \"_\" + json(\"metric_name\") }"
        value: "${! content() }"
        ttl: "600s"  # 10 minute correlation window
        
    # Store by time window for temporal correlation
    - cache:
        resource: "temporal_cache"
        operator: "set"
        key: "${! json(\"ship_id\") + \"_\" + (timestamp_unix() / 300 | floor).string() }"
        value: "${! content() }"
        ttl: "900s"  # 15 minute temporal correlation window

    # Correlation logic - only attempt correlation for specific scenarios
    - switch:
      - check: json("metric_name") == "cpu_usage" || json("metric_name") == "memory_usage"
        processors:
          # Look for related system metrics
          - try:
            - cache:
                resource: "correlation_cache"
                operator: "get"  
                key: "${! if json(\"metric_name\") == \"cpu_usage\" { json(\"ship_id\") + \"_\" + json(\"event_source\") + \"_memory_usage\" } else { json(\"ship_id\") + \"_\" + json(\"event_source\") + \"_cpu_usage\" } }"
      
      - check: json("event_source") == "basic_metrics"
        processors:
          # Look for related application logs
          - try:
            - cache:
                resource: "correlation_cache"
                operator: "get"
                key: "${! json(\"ship_id\") + \"_application_logs_log_anomaly\" }"
                
      - check: json("event_source") == "application_logs" 
        processors:
          # Look for related system metrics
          - try:
            - cache:
                resource: "correlation_cache"
                operator: "get"
                key: "${! json(\"ship_id\") + \"_basic_metrics_cpu_usage\" }"

    # Create comprehensive correlated incidents with safe null handling
    - mapping: |
        # Initialize incident classification
        root.incident_type = "single_anomaly"
        
        # Parse related event from cache (if available)
        let related = if meta("cache_result") != null && meta("cache_result").type() == "string" {
          meta("cache_result").parse_json() 
        } else {
          null
        }
        
        # Enhanced incident classification logic
        if this.is_enriched && this.operational_status != "normal" {
          # Enhanced operational incidents
          root.incident_type = if this.operational_status == "weather_impacted" {
            "weather_degradation"
          } else if this.operational_status == "system_overloaded" {
            "system_overload"
          } else if this.operational_status == "degraded_comms" {
            "communication_issues"
          } else {
            "operational_anomaly"
          }
          
        } else if this.event_source == "application_logs" && related != null && related.event_source == "basic_metrics" {
          # Application errors correlated with system metrics
          root.incident_type = if related.metric_name != null && (related.metric_name.contains("cpu") || related.metric_name.contains("memory")) {
            "application_system_correlation"
          } else {
            "application_infrastructure_issue"
          }
          
        } else if this.event_source == "basic_metrics" && related != null && related.event_source == "application_logs" {
          # System metrics correlated with application errors
          root.incident_type = "system_application_correlation"
          
        } else if related != null && 
          ((this.metric_name == "cpu_usage" && related.metric_name == "memory_usage") ||
           (this.metric_name == "memory_usage" && related.metric_name == "cpu_usage")) {
          # Traditional CPU/memory correlation
          root.incident_type = "resource_pressure"
          
        } else if this.is_enriched && this.enrichment_context != {} {
          # Multi-source correlation for enriched data
          root.incident_type = "enriched_anomaly"
        }
        
        # Build event list for correlation
        let all_events = [this]
        if related != null {
          all_events = all_events.append(related)
        }
        root.correlated_events = all_events
        
        # Calculate severity priority with comprehensive null safety
        let severity_map = {
          "critical": 4,
          "high": 3,
          "medium": 2,
          "warning": 2,
          "info": 1,
          "debug": 1
        }
        
        let current_severity = if this.severity != null && this.severity != "" { this.severity } else { "info" }
        let severity_priority = if severity_map.get(current_severity) != null { severity_map.get(current_severity) } else { 1 }
        let related_severity = if related != null && related.severity != null && related.severity != "" { related.severity } else { "info" }
        let related_priority = if related != null && severity_map.get(related_severity) != null { severity_map.get(related_severity) } else { 0 }
        
        # Calculate maximum priority safely 
        let max_priority = if severity_priority >= related_priority { severity_priority } else { related_priority }
        
        # Set incident severity based on max priority
        root.incident_severity = if max_priority == 4 {
          "critical"
        } else if max_priority == 3 {
          "high"
        } else if max_priority == 2 {
          "medium"
        } else {
          "low"
        }
        
        # Calculate correlation confidence
        root.correlation_confidence = if all_events.length() > 1 {
          0.85  # High confidence with correlated events
        } else if this.is_enriched {
          0.75  # Medium confidence for enriched single events
        } else {
          0.60  # Lower confidence for single basic events
        }
        
        # Add debug information with guaranteed non-null values
        root.debug_priorities = {
          "severity_priority": severity_priority,
          "related_priority": related_priority,
          "severity_value": current_severity,
          "related_exists": related != null,
          "max_priority": max_priority,
          "event_count": all_events.length()
        }
        
        # Ensure all required fields are never null
        root.ship_id = if this.ship_id != null && this.ship_id != "" { this.ship_id } else { "unknown-ship" }
        root.incident_type = if this.incident_type != null && this.incident_type != "" { this.incident_type } else { "single_anomaly" }

    # CRITICAL FIX: Enhanced suppression check - prevent duplicate incidents with multiple keys
    - try:
        drop_on_err: true
        processors:
          - cache:
              resource: "suppression_cache"
              operator: "get"
              # More granular suppression key including metric_name and service
              key: "${! json(\"incident_type\") + \"_\" + json(\"ship_id\") + \"_\" + json(\"metric_name\") + \"_\" + json(\"service\") }"

    # CRITICAL FIX: Additional suppression for tracking_id-based deduplication
    - try:
        drop_on_err: true
        processors:
          - cache:
              resource: "tracking_suppression_cache"
              operator: "get"
              key: "${! if json(\"tracking_id\") != null && json(\"tracking_id\") != \"\" { json(\"tracking_id\") } else { json(\"ship_id\") + \"_\" + json(\"metric_name\") + \"_\" + (json(\"processing_timestamp\") / 60 | floor).string() } }"

    # Only process if not suppressed by either check
    - switch:
      - check: (meta("cache_result") == null || meta("cache_result") == "") && (meta("tracking_suppression_cache") == null || meta("tracking_suppression_cache") == "")
        processors:
          # CRITICAL FIX: More granular suppression with longer TTL for similar incidents
          - cache:
              resource: "suppression_cache"
              operator: "set" 
              key: "${! json(\"incident_type\") + \"_\" + json(\"ship_id\") + \"_\" + json(\"metric_name\") + \"_\" + json(\"service\") }"
              value: "${! json(\"incident_id\") }"  # Store the incident ID for reference
              ttl: "900s"  # Suppress for 15 minutes (longer for better deduplication)
              
          # CRITICAL FIX: Tracking-based suppression
          - cache:
              resource: "tracking_suppression_cache"
              operator: "set"
              key: "${! if json(\"tracking_id\") != null && json(\"tracking_id\") != \"\" { json(\"tracking_id\") } else { json(\"ship_id\") + \"_\" + json(\"metric_name\") + \"_\" + (json(\"processing_timestamp\") / 60 | floor).string() } }"
              value: "${! json(\"incident_id\") }"
              ttl: "1800s"  # Suppress for 30 minutes for tracking-based deduplication
              
          # Create final incident event with complete metadata
          - mapping: |
              # Core incident fields
              root.event_type = "incident"
              root.incident_id = uuid_v4()
              root.created_at = now()
              root.updated_at = now()
              root.status = "open"
              root.acknowledged = false
              
              # CRITICAL FIX: Ensure all required fields are populated from processed data
              root.incident_type = if this.incident_type != null && this.incident_type != "" { this.incident_type } else { "single_anomaly" }
              root.incident_severity = if this.incident_severity != null && this.incident_severity != "" { this.incident_severity } else { "medium" }
              root.ship_id = if this.ship_id != null && this.ship_id != "" { this.ship_id } else { "unknown-ship" }
              root.service = if this.service != null && this.service != "" { this.service } else { "unknown_service" }
              root.metric_name = if this.metric_name != null && this.metric_name != "" { this.metric_name } else { "unknown_metric" }
              root.metric_value = if this.metric_value != null { this.metric_value } else { 0.0 }
              root.anomaly_score = if this.anomaly_score != null { this.anomaly_score } else { 0.5 }
              root.device_id = if this.device_id != null && this.device_id != "" { this.device_id } else { "unknown-device" }
              root.correlation_id = if this.correlation_id != null && this.correlation_id != "" { this.correlation_id } else { uuid_v4() }
              
              # CRITICAL FIX: Include tracking information for traceability
              root.tracking_id = if this.tracking_id != null && this.tracking_id != "" { this.tracking_id } else { null }
              
              # CRITICAL FIX: Enhanced timeline with more context
              root.timeline = [
                {
                  "timestamp": now(),
                  "event": "incident_created",
                  "description": "Incident created by anomaly correlation - " + root.incident_type + " on " + root.ship_id,
                  "source": "benthos_correlation",
                  "metadata": {
                    "anomaly_score": root.anomaly_score,
                    "metric_name": root.metric_name,
                    "metric_value": root.metric_value,
                    "tracking_id": root.tracking_id,
                    "correlation_confidence": if this.correlation_confidence != null { this.correlation_confidence } else { 0.6 }
                  }
                }
              ]
              
              # CRITICAL FIX: Enhanced metadata including all source data
              root.metadata = {
                "correlation_confidence": if this.correlation_confidence != null { this.correlation_confidence } else { 0.6 },
                "event_source": if this.event_source != null { this.event_source } else { "unknown" },
                "host": if this.host != null { this.host } else { "unknown" },
                "original_timestamp": if this.timestamp != null { this.timestamp } else { now() },
                "processing_metadata": if this.input_metadata != null { this.input_metadata } else { {} },
                "correlated_events_count": if this.correlated_events != null { this.correlated_events.length() } else { 1 },
                "ship_id_source": if this.ship_id_source != null { this.ship_id_source } else { "unknown" },
                "registry_metadata": if this.registry_metadata != null { this.registry_metadata } else { {} }
              }
              
              # Enhanced runbook suggestions based on incident type and context
              root.suggested_runbooks = if this.incident_type == "resource_pressure" {
                ["investigate_high_resource_usage", "scale_resources", "check_system_limits"]
              } else if this.incident_type == "weather_degradation" {
                ["weather_response_protocol", "switch_backup_comm", "adjust_satellite_parameters"]
              } else if this.incident_type == "communication_issues" {
                ["comm_system_diagnostics", "antenna_alignment_check", "backup_communication"]
              } else if this.incident_type == "system_overload" {
                ["load_balancing", "process_optimization", "resource_scaling"]
              } else if this.incident_type == "application_system_correlation" {
                ["investigate_app_system_correlation", "check_resource_limits", "review_application_logs"]
              } else if this.metric_name == "cpu_usage" {
                ["investigate_cpu_usage", "check_cpu_intensive_processes"]  
              } else if this.metric_name == "memory_usage" {
                ["investigate_memory_usage", "check_memory_leaks"]
              } else if this.event_source == "application_logs" {
                ["review_application_logs", "check_application_health", "investigate_error_patterns"]
              } else {
                ["generic_investigation", "check_system_health"]
              }

      # Drop suppressed events
      - processors:
          - mapping: "root = deleted()"

# Output: Send correlated incidents to multiple destinations
output:
  broker:
    pattern: fan_out
    outputs:
      # Send to NATS for incident management
      - nats:
          urls: ["nats://nats:4222"]
          subject: "incidents.created"
          
      # Log to console for debugging  
      - stdout: {}

# Caching resources for correlation and suppression
cache_resources:
  - label: "correlation_cache" 
    memory:
      default_ttl: "600s"
      
  - label: "temporal_cache"
    memory:
      default_ttl: "900s"
      
  - label: "suppression_cache"
    memory:
      default_ttl: "900s"  # Increased TTL for better deduplication
      
  # CRITICAL FIX: New cache for tracking-based suppression
  - label: "tracking_suppression_cache"
    memory:
      default_ttl: "1800s"  # 30 minutes for tracking-based deduplication

# Metrics and monitoring
metrics:
  prometheus: {}
    
logger:
  level: TRACE
  format: json
  add_timestamp: true