# Device Registry Integration Processor for Benthos
# This processor performs hostname â†’ ship_id lookups using the Device Registry service
# Add this to your Benthos pipeline before other processing steps

# Step 1: Prepare for device registry lookup
- mapping: |
    # Enhanced ship_id resolution using Device Registry service
    root.original_ship_id = this.ship_id
    root.original_host = this.host
    root.registry_lookup_attempted = false
    root.registry_lookup_success = false
    
    # First check if we already have a valid ship_id
    if this.ship_id != null && this.ship_id != "" && !this.ship_id.contains("unknown") {
      # Valid ship_id already exists, keep it
      root.ship_id = this.ship_id
      root.ship_id_source = "original_field"
      root.skip_lookup = true
    } else {
      # Need to resolve ship_id via registry lookup
      root.registry_lookup_attempted = true
      
      # Try hostname-based lookup via Device Registry
      let hostname = if this.host != null && this.host != "" { 
        this.host 
      } else if this.labels != null && this.labels.instance != null { 
        this.labels.instance 
      } else if this.hostname != null && this.hostname != "" {
        this.hostname
      } else {
        null
      }
      
      root.lookup_hostname = hostname
      root.skip_lookup = hostname == null
    }

# Step 2: HTTP lookup using HTTP processor 
- branch:
    request_map: |
      # Only process messages that need registry lookup
      if this.skip_lookup != true && this.lookup_hostname != null {
        root = this
      } else {
        root = deleted()
      }
    processors:
      - http:
          url: http://device-registry:8080/lookup/${! this.lookup_hostname }
          verb: GET
          retries: 0
          timeout: 5s
      - mapping: |
          # Process HTTP response
          root.registry_lookup_success = this.status_code == 200
          if this.status_code == 200 {
            root.registry_response = this.body.parse_json().catch(error -> null)
          } else {
            root.registry_response = null
          }
    result_map: |
      # Merge HTTP response back into original message
      if this.skip_lookup != true {
        root.registry_lookup_success = this.registry_lookup_success
        root.registry_response = this.registry_response
      }

# Step 3: Process registry results and apply fallback logic
- mapping: |
    # Apply registry results or fallback logic
    if this.skip_lookup != true {
      if this.registry_lookup_success == true && this.registry_response != null && this.registry_response.mapping != null && this.registry_response.mapping.ship_id != null {
        # Successful registry lookup
        root.ship_id = this.registry_response.mapping.ship_id
        root.ship_id_source = "registry_lookup"
        root.registry_lookup_success = true
        root.device_id = this.registry_response.mapping.device_id
        root.device_type = this.registry_response.mapping.device_type
        root.ship_name = this.registry_response.mapping.ship_name
      } else if this.lookup_hostname != null {
        # Registry failed or returned invalid data, use hostname fallback
        root.ship_id = if this.lookup_hostname.contains("-") {
          this.lookup_hostname.split("-").index(0) + "-ship"
        } else {
          this.lookup_hostname + "-ship"
        }
        root.ship_id_source = if this.registry_lookup_success == true { 
          "registry_failed_hostname_fallback" 
        } else { 
          "registry_unavailable_hostname_fallback" 
        }
      } else {
        # No hostname available, use ultimate fallback
        root.ship_id = "unknown-ship"
        root.ship_id_source = "no_hostname"
      }
    }
    
    # Add registry lookup metadata for debugging
    root.registry_metadata = {
      "lookup_attempted": root.registry_lookup_attempted,
      "lookup_success": root.registry_lookup_success,
      "ship_id_source": root.ship_id_source,
      "original_host": root.original_host,
      "resolved_ship_id": root.ship_id,
      "timestamp": now()
    }

# Step 4: Registry last_seen update (optional)
- branch:
    request_map: |
      # Only update if we have valid hostname and successful registry lookup
      if this.host != null && this.host != "" && this.host != "unknown" && this.registry_lookup_success == true {
        root = this
      } else {
        root = deleted()
      }
    processors:
      - http:
          url: http://device-registry:8080/lookup/${! this.host }/update-last-seen
          verb: POST
          retries: 0
          timeout: 5s
      - mapping: |
          # Process update response
          root.registry_update_success = this.status_code == 200
          root.registry_update_note = if this.status_code == 200 { 
            "last_seen_updated" 
          } else { 
            "update_failed_or_not_found" 
          }
    result_map: |
      # Merge update response back
      root.registry_update_success = this.registry_update_success
      root.registry_update_note = this.registry_update_note

# Step 5: Device type enrichment processor  
- mapping: |
    # Clean up temporary fields and finalize device type
    root = this.without("skip_lookup", "lookup_hostname", "registry_response")
    
    # Enhance device_type classification if not already set by registry
    if root.device_type == null || root.device_type == "" {
      root.device_type = if this.service != null {
        if this.service.contains("nginx") || this.service.contains("web") {
          "server"
        } else if this.service.contains("postgres") || this.service.contains("mysql") {
          "server" 
        } else if this.service.contains("network") || this.service.contains("snmp") {
          "network"
        } else {
          "server"
        }
      } else if this.metric_name != null {
        if this.metric_name.contains("cpu") || this.metric_name.contains("memory") {
          "server"
        } else if this.metric_name.contains("network") || this.metric_name.contains("interface") {
          "network"
        } else {
          "unknown"
        }
      } else {
        "unknown"
      }
    }
    
    # Ensure metric_name is safe for cache operations
    root.metric_name = if this.metric_name != null && this.metric_name != "" { 
      this.metric_name 
    } else { 
      "unknown_metric" 
    }
    
    # Add enhanced event context
    root.event_context = {
      "ship_id": root.ship_id,
      "device_type": root.device_type,
      "device_id": if root.device_id != null { root.device_id } else { "unknown" },
      "hostname": if this.host != null { this.host } else { "unknown" },
      "source": if this.event_source != null { this.event_source } else { "unknown" }
    }